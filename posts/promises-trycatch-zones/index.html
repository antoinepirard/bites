<!DOCTYPE html><html class="no-js" lang="en"><head><meta charset="utf-8" /><title>Comparing Node.js Promises, Try/Catch, Angular Zone.js and yes, Zone | Bites from Good Eggs</title><meta name="author" content="Alex Gorbatchev" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="shortcut icon" href="/favicon.ico?v=2" /><link rel="stylesheet" href="/styles/main.css" /><link rel="alternate" title="RSS" type="application/rss+xml" href="/rss" /><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-26193287-5', 'github.io');
ga('send', 'pageview');</script></head><body><header><h1><a href="/">Bites</a></h1><ul class="unstyled nav"><li><a href="/">Blog</a></li><li><a href="/open_source/">Open Source</a></li><li><a href="/news/">News</a></li></ul></header><div id="main"><div id="content"><div><article class="post" role="article"><header><img class="author" src="http://fpio.goodeggs.com/api/file/DkcUdnQSE63IauiZq4CW/convert?w=150&amp;h=150&amp;fit=crop&amp;align=faces&amp;cache=true" alt="Alex Gorbatchev" /><h1 class="entry-title">Comparing Node.js Promises, Try/Catch, Angular Zone.js and yes, Zone</h1><p class="meta"><a class="entry-author-name" href="/authors/alex_gorbatchev/">Alex Gorbatchev</a> on <time datetime="2014-06-09T19:00:00.000Z">June 9th, 2014</time></p></header><div class="entry-content"><blockquote>
<p>Reposted with permission by <a href="http://strongloop.com/">StrongLoop</a>. Originally appeared on <a href="http://strongloop.com/strongblog/comparing-node-js-promises-trycatch-zone-js-angular/">April 16, 2014</a>.</p>
</blockquote>
<h1 id="handling-errors-in-async-flow">Handling errors in async flow</h1>
<p>In the <a href="http://strongloop.com/strongblog/node-js-callback-hell-promises-generators/">previous article</a> we&#39;ve talked about managing async flow and escaping the <a href="http://callbackhell.com/">callback hell</a>.</p>
<h2 id="the-problem">The problem</h2>
<p>Handling errors in asynchronous flow is pretty straightforward and easy. Handling errors in asynchronous flow in a clean and easy to follow manner - not so much.</p>
<!-- more -->

<p>Lets look at the following code:</p>
<pre><code class="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateDependencies</span><span class="hljs-params">(packageName, done)</span> </span>{
      findPackage(packageName, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, content)</span> </span>{
        <span class="hljs-keyword">if</span> (err) {
          done(err);
        }
        <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">try</span> {
            package = <span class="hljs-built_in">JSON</span>.parse(content);
          }
          <span class="hljs-keyword">catch</span> (e) {
            done(e);
          }

          findDependencies(package, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, dependencies)</span>) </span>{
            <span class="hljs-keyword">if</span> (err) {
              done(err);
            }
            <span class="hljs-keyword">else</span> {
              processDependencies(dependencies, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> </span>{
                <span class="hljs-keyword">if</span> (err) {
                  done(err);
                }
                <span class="hljs-keyword">else</span> {
                  done(<span class="hljs-literal">null</span>, dependencies);
                }
              });
            }
          });
        }
      });
    }</code></pre>

<p>We are covering all possible failure cases here using combination of <code>try/catch</code> and callback error handling, but boy do we repeat ourselves over and over again. Lets try and rewrite this!</p>
<h2 id="error-handling-using-try-catch">Error handling using try/catch</h2>
<pre><code class="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateDependencies</span><span class="hljs-params">(packageName, done)</span> </span>{
      <span class="hljs-keyword">try</span> {
        findPackage(packageName, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, content)</span> </span>{
          <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;

          findDependencies(<span class="hljs-built_in">JSON</span>.parse(content), <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, dependencies)</span>) </span>{
            <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;

            processDependencies(dependencies, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> </span>{
              <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;

              done(<span class="hljs-literal">null</span>, dependencies);
            });
          });
        });
      } <span class="hljs-keyword">catch</span> (e) {
        done(e);
      }
    }</code></pre>

<p>Nice! That&#39;s much better. However, if we run this now, no errors will be caught. What&#39;s going on here?</p>
<p><code>try/catch</code> idiom works very well when you have fully synchronous code, but asynchronous operations render it useless.</p>
<p>The outer <code>try/catch</code> block will never catch anything because <code>findPackage</code> is asynchronous. The function will begin its course while the outer stack runs through and gets to the last line without any errors.</p>
<p>If an error occurs at some point in the future inside asynchronous <code>findPackage</code> - <strong>nothing will be caught</strong>.</p>
<p><img src="/images/posts/promises-trycatch-zones/catch-fail.gif"/></p>
<p>Not useful.</p>
<h2 id="error-handling-using-promises">Error handling using promises</h2>
<p>In the <a href="http://strongloop.com/strongblog/node-js-callback-hell-promises-generators/">previous article</a> we&#39;ve talked about managing asynchronous flow and escaping the <a href="http://callbackhell.com/">callback hell</a> with promises. Lets put this promises to work here and rewrite this function.</p>
<p>For the sake of moving forward quicker lets assume we are using <a href="https://github.com/petkaantonov/bluebird">Bluebird</a> promises library and that all our APIs now return promises instead of taking callbacks:</p>
<pre><code class="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateDependencies</span><span class="hljs-params">(packageName)</span> </span>{
      <span class="hljs-keyword">return</span> findPackage(packageName)
        .then(<span class="hljs-built_in">JSON</span>.parse)
        .then(findDependencies)
        .then(processDependencies)
        .then(res.send)
        ;
    }</code></pre>

<p>Oh wow, that is so much nicer! Right? Right!</p>
<p>But Alex, &quot;we&#39;ve lost our error handling&quot;, you might say. That&#39;s right, we don&#39;t need to do anything special here to propagate error because we return a promise and there&#39;s built in support for error flow. Lets see how error handling might look like with promises:</p>
<pre><code class="js">button.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      updateDependencies(<span class="hljs-string">"packageName"</span>)
        .then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(dependencies)</span> </span>{
          output.innerHTML = dependencies.join(<span class="hljs-string">"\n"</span>);
        })
        .catch(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> </span>{
          output.innerHTML = <span class="hljs-string">"There was an error"</span>;
        });
    });</code></pre>

<p>Very slick, I&#39;m a fan!</p>
<h2 id="error-using-zones">Error using Zones</h2>
<p>Handling rejected promises works really well when we are in full control of the flow. But what happens if some third-party code throws an error during an asynchronous operation? Lets look at another example:</p>
<pre><code class="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thirdPartyFunction</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeXHR</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Invalid dependencies"</span>);
      }

      setTimeout(fakeXHR, <span class="hljs-number">100</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
      button.on(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span><span class="hljs-params">()</span> </span>{
        thirdPartyFunction();
      });
    }

    main();</code></pre>

<p>In this case, we wouldn&#39;t have a chance to catch and process the error. Generally, the only recourse here is using half baked <code>window.onerror</code> that doesn&#39;t give you any stack information at all. At least you can log something, right? Not that there&#39;s much to log:</p>
<pre><code>Uncaught Error: Invalid dependencies
    fakeXHR
</code></pre><p>Up until recently that was pretty much all we had. However, this january <a href="https://github.com/btford">Brian Ford</a> of the <a href="http://angularjs.org">angular.js</a> fame has released <a href="https://github.com/btford/zone.js/">Zone.js</a> which aims to help tackle this.</p>
<p>Basically, <a href="https://github.com/btford/zone.js/">Zone.js</a> <strong>overrides all asynchronous functions in the browser</strong> with custom implementations which allows it to keep track of the context. Dangerous? Yes! But as we say in Soviet Russia, &quot;he who doesn&#39;t risk never gets to drink champagne&quot; (or in English &quot;nothing ventured, nothing gained&quot;).</p>
<p>Anyways, lets look at how this works. Assuming you have included <code>zones.js</code> and <code>long-stack-trace-zone.js</code> as per the docs, we just change <code>main()</code> call to:</p>
<pre><code class="js">zone.fork(Zone.longStackTraceZone).run(main);</code></pre>

<p>Refresh, click the button, and now our stack looks like this:</p>
<pre><code class="bash">Error: Invalid dependencies
    at fakeXHR (script.js:<span class="hljs-number">7</span>:<span class="hljs-number">11</span>)
    at Zone.run (zones.js:<span class="hljs-number">41</span>:<span class="hljs-number">19</span>)
    at zoneBoundFn (zones.js:<span class="hljs-number">27</span>:<span class="hljs-number">19</span>)
--- Tue Mar <span class="hljs-number">25</span> <span class="hljs-number">2014</span> <span class="hljs-number">21</span>:<span class="hljs-number">20</span>:<span class="hljs-number">32</span> GMT-<span class="hljs-number">0700</span> (PDT) - <span class="hljs-number">106</span>ms ago
Error
    at Function.getStacktraceWithUncaughtError (long-stack-trace-zone.js:<span class="hljs-number">24</span>:<span class="hljs-number">32</span>)
    at Zone.longStackTraceZone.fork (long-stack-trace-zone.js:<span class="hljs-number">70</span>:<span class="hljs-number">43</span>)
    at Zone.bind (zones.js:<span class="hljs-number">25</span>:<span class="hljs-number">21</span>)
    at zone.(anonymous function) (zones.js:<span class="hljs-number">61</span>:<span class="hljs-number">27</span>)
    at marker (zones.js:<span class="hljs-number">66</span>:<span class="hljs-number">25</span>)
    at thirdPartyFunction (script.js:<span class="hljs-number">10</span>:<span class="hljs-number">3</span>)
    at HTMLButtonElement.onClick (script.js:<span class="hljs-number">15</span>:<span class="hljs-number">5</span>)
    at HTMLButtonElement.x.event.dispatch (jquery.js:<span class="hljs-number">5</span>:<span class="hljs-number">10006</span>)
    at HTMLButtonElement.y.handle (jquery.js:<span class="hljs-number">5</span>:<span class="hljs-number">6789</span>)
    at Zone.run (zones.js:<span class="hljs-number">41</span>:<span class="hljs-number">19</span>)
--- Tue Mar <span class="hljs-number">25</span> <span class="hljs-number">2014</span> <span class="hljs-number">21</span>:<span class="hljs-number">20</span>:<span class="hljs-number">32</span> GMT-<span class="hljs-number">0700</span> (PDT) - <span class="hljs-number">1064</span>ms ago
Error
    at getStacktraceWithUncaughtError (long-stack-trace-zone.js:<span class="hljs-number">24</span>:<span class="hljs-number">32</span>)
    at Function.Zone.getStacktrace (long-stack-trace-zone.js:<span class="hljs-number">37</span>:<span class="hljs-number">15</span>)
    at Zone.longStackTraceZone.fork (long-stack-trace-zone.js:<span class="hljs-number">70</span>:<span class="hljs-number">43</span>)
    at Zone.bind (zones.js:<span class="hljs-number">25</span>:<span class="hljs-number">21</span>)
    at HTMLButtonElement.obj.addEventListener (zones.js:<span class="hljs-number">132</span>:<span class="hljs-number">37</span>)
    at Object.x.event.add (jquery.js:<span class="hljs-number">5</span>:<span class="hljs-number">7262</span>)
    at HTMLButtonElement.&lt;anonymous&gt; (jquery.js:<span class="hljs-number">5</span>:<span class="hljs-number">14336</span>)
    at Function.x.extend.each (jquery.js:<span class="hljs-number">4</span>:<span class="hljs-number">4575</span>)
    at x.fn.x.each (jquery.js:<span class="hljs-number">4</span>:<span class="hljs-number">1626</span>)
    at x.fn.extend.on (jquery.js:<span class="hljs-number">5</span>:<span class="hljs-number">14312</span>)</code></pre>

<p>What the what?? Cool! We can now see that the relevant code path started in our <code>onClick</code> method and went into <code>thirdPartyFunction</code>.</p>
<p>The cool part is, since <a href="https://github.com/btford/zone.js/">Zone.js</a> overrides browser methods, it doesn&#39;t matter what libraries you use. It just works.</p>
<h2 id="another-async-flow-control-project-called-zones-">Another async flow control project called Zones?</h2>
<p>Yep, StrongLoop’s <a href="https://github.com/piscisaureus">Bert Belder</a> has been working on a similar idea called “<a href="https://www.npmjs.org/package/zone">Zone</a>“ for a few months now. (Not to be confused with the Angular <a href="https://github.com/btford/zone.js/">Zone.js</a> project we&#39;ve just been discussing, which shares the same name and some technical characteristics. Yeah, it’s a little confusing, but we are actively working with <a href="https://github.com/btford">Brian Ford</a> on how to potentially bring together these two projects for the mutual benefit of the JavaScript and Node communities. Stay tuned!)</p>
<h2 id="why-a-node-specific-zones-project-">Why a Node-specific Zones project?</h2>
<p>Currently, there are a couple of problems that make it really hard to deal with asynchronous control flow in Node that Zones looks to address. Specifically:</p>
<ul>
<li>Stack traces are useless when an asynchronous function fails.</li>
<li>Asynchronous functions are hard to compose into more high-level APIs. Imagine implementing a simple asynchronous API like bar(arg1, arg2, cb) where cb is the error-first callback that the user of the API specifies. To implement this correctly you must take care:<ul>
<li>to always call the callback</li>
<li>don’t call the callback more than once</li>
<li>don’t synchronously throw and also call the callback</li>
<li>don’t call the callback synchronously</li>
</ul>
</li>
<li>It is difficult to handle errors that are raised asynchronously. Typically node will crash. If the uses chooses to ignore the error, resources may leak. Zones should make it easy to handle errors and to avoid resource leaks.</li>
<li>Sometimes there is a need to associate user data to an asynchronous flow. There is currently no way to do this.</li>
</ul>
<p>Want to learn more about Zones? Stay tuned for more information in the coming weeks. Follow us on <a href="https://twitter.com/StrongLoop">Twitter</a> or subscribe to our <a href="http://strongloop.com/newsletter-registration/">newsletter</a> to make sure you don’t miss the announcements.</p>
<h2 id="what-s-next-">What&#39;s next?</h2>
<ul>
<li>Watch <a href="http://www.youtube.com/watch?v=3IqtmUscE_U">Brian&#39;s presentation</a> from ngconf 2014, it&#39;s pretty cool!</li>
<li>Add <a href="https://github.com/btford/zone.js/">Zone.js</a> to your application.</li>
<li>Profit!</li>
</ul>
<p><img src="/images/posts/promises-trycatch-zones/party.gif"/></p>
</div><footer><p class="meta"><a class="basic-alignment left" href="/posts/you-forgot-about-bfcache/">&laquo; You Forgot About bfcache!</a><a class="basic-alignment right" href="/posts/mobile-page-load/">Loading Scripts in the Critical Path: A Commerce Case Study &raquo;</a></p><div id="disqus_thread"></div><script>window.disqus_shortname = 'promises-trycatch-zones'; window.disqus_url = 'http://bites.goodeggs.com/posts/promises-trycatch-zones/'</script><script async="async" src="//promises-trycatch-zones.disqus.com/embed.js"></script></footer></article></div></div></div><footer><div class="mission">Our mission is to grow and sustain local food systems worldwide.</div><p>©2013 Good Eggs, Inc</p></footer></body></html>