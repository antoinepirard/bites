<!DOCTYPE html><html class="no-js" lang="en"><head><meta charset="utf-8" /><title>Export This: Interface Design Patterns for Node.js Modules | Bites from Good Eggs</title><meta name="author" content="Alon Salant" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="icon" type="image/png" href="../../favicon.png" /><link rel="stylesheet" href="../../styles/main.css" /><link rel="alternate" title="RSS" type="application/rss+xml" href="../../rss" /><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-26193287-5', 'github.io');
ga('send', 'pageview');</script></head><body><header><h1><a href="../../">Bites</a></h1><ul class="unstyled nav"><li><a href="../../">Blog</a></li><li><a href="../../open_source">Open Source</a></li><li><a href="../../news">News</a></li></ul></header><div id="main"><div id="content"><div><article class="hentry" role="article"><header><h1 class="entry-title">Export This: Interface Design Patterns for Node.js Modules</h1><p class="meta"><a href="../../authors/alon_salant/">Alon Salant</a> on <time datetime="2014-01-12T00:00:00.000Z">January 12th, 2014</time></p></header><div class="entry-content"><p>When you require a module in Node, what are you getting back? When you write a module, what options do you have for designing its interface?</p>
<p>When I was first learning to work in Node I found the sheer number of ways to do things to be a bit overwhelming. JavaScript is extremely flexible and the community of developers contributing to open source seem to have different styles for implementing the same thing.</p>
<p>On my journey with Node I&#39;ve been keeping an eye out the Good Way to do things and adopting them for use in my own work and in our work at Good Eggs.</p>
<p>In this post I&#39;ll share my observations of the Node module system and the ways in which you can use it to encapsulate and share code. My goal is to identify and illustrate useful patterns for module interface design and to help you understand when and how to use them in your own work.</p>
<p>I discuss seven patterns below, many of which can be used in combination. They are:</p>
<ul>
<li><a href="../../posts/export-this#namespace">Exports a Namespace</a></li>
<li><a href="../../posts/export-this#function">Exports a Function</a></li>
<li><a href="../../posts/export-this#higher_order_function">Exports a Higher Order Function</a></li>
<li><a href="../../posts/export-this#constructor">Exports a Constructor</a></li>
<li><a href="../../posts/export-this#singleton">Exports a Singleton</a></li>
<li><a href="../../posts/export-this#global_object">Extends a Global Object</a></li>
<li><a href="../../posts/export-this#monkey_patch">Applies a Monkey Patch</a></li>
</ul>
<!-- more -->

<h2 id="require-exports-and-module-exports">require, exports and module.exports</h2>
<p>First some fundamentals.</p>
<p>In Node requiring a file is requiring the module it defines. All modules have a reference to an implicit <code>module</code> object whose property <code>module.exports</code> is what is returned when you call <code>require</code>. A reference to <code>module.exports</code> is also available as <code>exports</code>.</p>
<p>It&#39;s as if there were an implicit line at the beginning of each module that reads:</p>
<pre><code>var exports = module.exports = {};</code></pre>
<p>If you want to export a function, you have to assign it to <code>module.exports</code>. Assigning a function to <code>exports</code> would just reassign the <code>exports</code> reference but <code>module.exports</code> would still point at the original empty object.</p>
<p>So we can define a module <code>function.js</code> that exports a function:</p>
<pre><code>module.exports = function () {
  return {name: &#39;Jane&#39;};
};</code></pre>
<p>and require it with:</p>
<pre><code>var func = require(&#39;./function&#39;);</code></pre>
<p>An important behavior of <code>require</code> is that it caches the value of <code>module.exports</code> and returns that same value for all future calls to <code>require</code>. It caches based on the absolute file path of the required file. So if you want your module to be able to return different values, you should have it export a function that can then be invoked to return a new value.</p>
<p>To demonstrate with the Node REPL:</p>
<pre><code>$ node
&gt; f1 = require(&#39;/Users/alon/Projects/export_this/function&#39;);
[Function]
&gt; f2 = require(&#39;./function&#39;); // Same location
[Function]
&gt; f1 === f2
true
&gt; f1() === f2()
false</code></pre>
<p>You can see that <code>require</code> is returning the same function instance but that the objects returned by that function are different instances for each call.</p>
<p>For more detail on Node&#39;s module system <a href="http://nodejs.org/api/modules.html">the core docs</a> provide good detail and are worth a read.</p>
<p>And now on to the interface patterns.</p>
<p><a name='namespace'></a></p>
<h2 id="exports-a-namespace">Exports a Namespace</h2>
<p>A simple and common pattern is to export an object with a number of properties, primarily but not limited to functions. This allows the code requiring the module to pull in a collection of related functionality under a single namespace.</p>
<p>When you require a module that exports a namespace, you&#39;ll usually either assign the entire namespace to a variable and use its members through that reference, or assign members directly to local variables:</p>
<pre><code>var fs = require(&#39;fs&#39;),
    readFile = fs.readFile,
    ReadStream = fs.ReadStream;

readFile(&#39;./file.txt&#39;, function(err, data) {
  console.log(&quot;readFile contents: &#39;%s&#39;&quot;, data);
});

new ReadStream(&#39;./file.txt&#39;).on(&#39;data&#39;, function(data) {
  console.log(&quot;ReadStream contents: &#39;%s&#39;&quot;, data);
});</code></pre>
<p>Here&#39;s what the <a href="https://github.com/joyent/node/blob/e5346932bcbc523489c9418b82fde31cb666ee99/lib/fs.js#L33"><code>fs</code> core module</a> is doing:</p>
<pre><code>var fs = exports;</code></pre>
<p>It first assigns the local variable <code>fs</code> to the implicit exports object and then assigns function references to properties of <code>fs</code>. Because <code>fs</code> references <code>exports</code> and exports is the object you get when you call <code>require(&#39;fs&#39;)</code> anything assigned to <code>fs</code> will be available on the object you get from <code>require</code>.</p>
<pre><code>fs.readFile = function(path, options, callback_) {
  // ...
};</code></pre>
<p>Anything is fair game. It then exports a constructor:</p>
<pre><code>fs.ReadStream = ReadStream;

function ReadStream(path, options) {
  // ...
}
ReadStream.prototype.open = function() {
  // ...
}</code></pre>
<p>When exporting a namespace, you can assign properties to <code>exports</code> as the <code>fs</code> module does above, or assign a new object to <code>module.exports</code>.</p>
<pre><code>module.exports = {
  version: &#39;1.0&#39;,

  doSomething: function() {
    //...
  }
}</code></pre>
<p>A common use of exporting a namespace is to export the root of another module so that one require statement gives the caller access to a number of other modules. At Good Eggs, we implement each of our domain models in a separate module that exports the model constructor (see <a href="#constructor">Exports a Constructor</a> below) and then have an index file in the directory where the models live that exports all of the models. This allows us to pull in our models under a <code>models</code> namespace.</p>
<pre><code>var models = require(&#39;./models&#39;),
    User = models.User,
    Product = models.Product;</code></pre>
<p>For CoffeeScript users, <a href="http://coffeescript.org/#destructuring">destructuring assignment</a> make this even cleaner.</p>
<pre><code>{User, Product} = require &#39;./models&#39;</code></pre>
<p><code>index.js</code> might look like:</p>
<pre><code>exports.User = require(&#39;./user&#39;);
exports.Person = require(&#39;./person&#39;);</code></pre>
<p>In reality, we use a small library that requires all sibling files and exports their modules with CamelCase names so the <code>index.js</code> file in our models directory actually reads:</p>
<pre><code>module.exports = require(&#39;../lib/require_siblings&#39;)(__filename);</code></pre>
<p><a name='function'></a></p>
<h2 id="exports-a-function">Exports a Function</h2>
<p>Another pattern is to export a function as the interface to a module. A common use of this pattern is to export a factory function that returns an object when invoked. We see this when using <a href="http://expressjs.com">Express.js</a>:</p>
<pre><code>var express = require(&#39;express&#39;);
var app = express();

app.get(&#39;/hello&#39;, function (req, res) {
  res.send &quot;Hi there! We&#39;re using Express v&quot; + express.version;
});</code></pre>
<p>The function exported by Express is used to create a new Express application. In your own use of this pattern, your factory function may take arguments used to configure or initialize the object returned.</p>
<p>To export a function, you must assign your function to module.exports. <a href="https://github.com/visionmedia/express/blob/2e68ddbae9cec2d0b22f48f35ef4da964f51949e/lib/express.js#L18">Express does</a>:</p>
<pre><code>exports = module.exports = createApplication;

...

function createApplication () {
  ...
}</code></pre>
<p>It&#39;s assigning the <code>createApplication</code> function to <code>module.exports</code> and then to the implicit <code>exports</code> variable. Now <code>exports</code> is the function that the module exports.</p>
<p>Express also uses this exported function as a namespace:</p>
<pre><code>exports.version = &#39;3.1.1&#39;;</code></pre>
<p>Note that there&#39;s nothing to stop us from using the exported function as a namespace that can expose references to other functions, constructors or objects serving as namespaces themselves.</p>
<p>When exporting a function, it is good practice to name the function so that it will show up in stack traces. Note the stack trace differences in these two examples:</p>
<pre><code>// bomb1.js
module.exports = function () {
  throw new Error(&#39;boom&#39;);
};</code></pre>
<pre><code>// bomb2.js
module.exports = function bomb() {
  throw new Error(&#39;boom&#39;);
};</code></pre>
<pre><code>$ node
&gt; bomb = require(&#39;./bomb1&#39;);
[Function]
&gt; bomb()
Error: boom
    at module.exports (/Users/alon/Projects/export_this/bomb1.js:2:9)
    at repl:1:2
    ...
&gt; bomb = require(&#39;./bomb2&#39;);
[Function: bomb]
&gt; bomb()
Error: boom
    at bomb (/Users/alon/Projects/export_this/bomb2.js:2:9)
    at repl:1:2
    ...</code></pre>
<p>There are a couple specific cases of exporting a function that are worth calling out as distinct patterns.</p>
<p><a name='higher_order_function'></a></p>
<h2 id="exports-a-higher-order-function">Exports a Higher Order Function</h2>
<p>A higher-order function, or functor, is a function that  takes one or more functions as an input and/or outputs a function. We&#39;re talking about the latter case - a function that returns a function.</p>
<p>Exporting a higher order function is a useful pattern when you want to return a function from your module but need to take input that controls the behavior of that function.</p>
<p><a href="http://www.senchalabs.org/connect/">Connect middleware</a> provide a lot of pluggable functionality for Express and other web frameworks. A middleware is a function that takes three arguments - <code>(req, res, next)</code>. The convention in connect middleware is to export a function that when called returns the middleware function. This allows the exported function to take arguments that can be used to configure the middleware and are available through closure scope to the middleware when it is handling a request.</p>
<p>For example, here&#39;s the connect <a href="http://www.senchalabs.org/connect/query.html"><code>query</code> middleware</a> used internally by Express to parse query string parameters into a an object available as <code>req.query</code>.</p>
<pre><code>var connect = require(&#39;connect&#39;),
    query = require(&#39;connect/lib/middleware/query&#39;);

var app = connect();
app.use(query({maxKeys: 100}));</code></pre>
<p>The <code>query</code> source looks like:</p>
<pre><code>var qs = require(&#39;qs&#39;)
  , parse = require(&#39;../utils&#39;).parseUrl;

module.exports = function query(options){
  return function query(req, res, next){
    if (!req.query) {
      req.query = ~req.url.indexOf(&#39;?&#39;)
        ? qs.parse(parse(req).query, options)
        : {};
    }

    next();
  };
};</code></pre>
<p>For every request handled by the <code>query</code> middleware, the <code>options</code> argument available through closure scope is passed along to Node&#39;s core <code>qs</code> (query string) module.</p>
<p>This is a common and very flexible pattern for module design and one you are likely to find very useful in your own work.</p>
<p><a name='constructor'></a></p>
<h2 id="exports-a-constructor">Exports a Constructor</h2>
<p>We define classes in JavaScript with constructor functions and create instances of classes with the <code>new</code> keyword.</p>
<pre><code>function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  return &quot;Hi, I&#39;m Jane.&quot;;
};

var person = new Person(&#39;Jane&#39;);
console.log(person.greet()); // prints: Hi, I&#39;m Jane</code></pre>
<p>For this pattern implement a class-per-file and export the constructor to make your project organization clear and to make it easy for other developers to find the implementation of a class. At Good Eggs, we implement classes in files with underscore_names and assign them to CamelCase names.</p>
<pre><code>var Person = require(&#39;./person&#39;);

var person = new Person(&#39;Jane&#39;);</code></pre>
<p>The implementation might look like:</p>
<pre><code>function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  return &quot;Hi, I&#39;m &quot; + this.name;
};

module.exports = Person;</code></pre>
<p><a name='singleton'></a></p>
<h2 id="exports-a-singleton">Exports a Singleton</h2>
<p>Export a <a href="http://en.wikipedia.org/wiki/Singleton_pattern">singleton</a> when you want all users of your module to share the state and behavior of a single class instance.</p>
<p><a href="http://mongoosejs.com">Mongoose</a> is an object-document mapping library used to create rich domain models persisted in MongoDB.</p>
<pre><code>var mongoose = require(&#39;mongoose&#39;);
mongoose.connect(&#39;mongodb://localhost/test&#39;);

var Cat = mongoose.model(&#39;Cat&#39;, { name: String });

var kitty = new Cat({ name: &#39;Zildjian&#39; });
kitty.save(function (err) {
  if (err) // ...
  console.log(&#39;meow&#39;);
});</code></pre>
<p>What is that <code>mongoose</code> object we get back when we require Mongoose? Internally, the <code>mongoose</code> module is doing:</p>
<pre><code>function Mongoose() {
  //...
}

module.exports = exports = new Mongoose();</code></pre>
<p>Because <code>require</code> caches the value assigned to <code>module.exports</code>, all calls to <code>require(&#39;mongoose&#39;)</code> will return this same instance ensuring that it is a singleton in our application. Mongoose uses an object-oriented design to encapsulate and decouple functionality, maintain state and support readability and comprehension, but creates a simple interface to users by creating and exporting an instance of the Mongoose class.</p>
<p>It also uses this singleton instance as a namespace to make other constructors available if needed by the user, including the Mongoose constructor itself. You might use the <code>Mongoose</code> constructor to create additional instances of mongoose connecting to additional MongoDB databases.</p>
<p>Internally, Mongoose does:</p>
<pre><code>Mongoose.prototype.Mongoose = Mongoose;</code></pre>
<p>So that you can do:</p>
<pre><code>var mongoose = require(&#39;mongoose&#39;),
    Mongoose = mongoose.Mongoose;

var myMongoose = new Mongoose();
myMongoose.connect(&#39;mongodb://localhost/test&#39;);</code></pre>
<p><a name='global_object'></a></p>
<h2 id="extends-a-global-object">Extends a Global Object</h2>
<p>A required module can do more than just export a value. It can also modify global objects or objects returned when requiring other modules. It can define new global objects. It can just do this or do this in addition to exporting something useful.</p>
<p>Use this pattern when you need to extend or alter the behavior of global objects to provide the behavior delivered by your module. While certainly controversial and to be used judiciously (especially in open source work), this pattern can also be indispensable.</p>
<p><a href="https://github.com/visionmedia/should.js">Should.js</a> is an assertion library designed to be used in unit testing:</p>
<pre><code>require(&#39;should&#39;);

var user = {
    name: &#39;Jane&#39;
};

user.name.should.equal(&#39;Jane&#39;);</code></pre>
<p>Should.js <a href="https://github.com/visionmedia/should.js/blob/68000f47d01408cacb80441a1d9bf10ba423e54c/lib/should.js#L107-L113">extends Object with a non-enumerable property <code>should</code></a> to provide a clean syntax for writing unit test asserts. Internally, <code>should.js</code> does:</p>
<pre><code>var should = function(obj) {
  return new Assertion(util.isWrapperType(obj) ? obj.valueOf(): obj);
};

//...

exports = module.exports = should;

//...

Object.defineProperty(Object.prototype, &#39;should&#39;, {
  set: function(){},
  get: function(){
    return should(this);
  },
  configurable: true
});</code></pre>
<p>Note that while Should.js exports the <code>should</code> function its primary use is through the <code>should</code> function it has added to <code>Object</code>.</p>
<p><a name='monkey_patch'></a></p>
<h2 id="applies-a-monkey-patch">Applies a Monkey Patch</h2>
<p>By <a href="http://en.wikipedia.org/wiki/Monkey_patch">monkey patch</a> I&#39;m referring to &quot;the dynamic modifications of a class or module at runtime, motivated by the intent to patch existing third-party code as a workaround to a bug or feature which does not act as desired.&quot;</p>
<p>Implement a module to patch an existing module when it doesn&#39;t provide an interface to customizing its behavior in the way you need. This pattern is a variant of the previous. Instead of modifying a global object, we are relying on the caching behavior of Node&#39;s module system to patch the same instance of a module that other code gets when it requires that module.</p>
<p>By default Mongoose names MongoDB collections by lowercasing and pluralizing the model name. For a model named <code>CreditCardAccountEntry</code> we&#39;d end up with a collection named <code>creditcardaccountentries</code>. I prefer <code>credit_card_account_entries</code> and I want this behavior universally.</p>
<p>Here&#39;s the source for a module that patches <code>mongoose.model</code> when the module is required:</p>
<pre><code>var Mongoose = require(&#39;mongoose&#39;).Mongoose;
var _ = require(&#39;underscore&#39;);

var model = Mongoose.prototype.model;
var modelWithUnderScoreCollectionName = function(name, schema, collection, skipInit) {
  collection = collection || _(name).chain().underscore().pluralize().value();
  model.call(this, name, schema, collection, skipInit)
};
Mongoose.prototype.model = modelWithUnderScoreCollectionName</code></pre>
<p>When this module is required for the first time, it requires <code>mongoose</code>, redefines <code>Mongoose.prototype.model</code> and delegates back to the original implementation of <code>model</code>. Now all instances of <code>Mongoose</code> will have this new behavior. Note that it does not modify <code>exports</code> so the value returned to <code>require</code> will be the default empty <code>exports</code> object.</p>
<p>As a side note, if you do choose to monkey patch existing code, use a chaining technique similar to my example above. Add your behavior then delegate back to the original implementation. While not foolproof, it is the safest way to patch third party code allowing you to take advantage of future updates to the library and minimizing conflict with other patches that may be applied.</p>
<h2 id="export-away-">Export Away!</h2>
<p>The Node module system provides a simple mechanism for encapsulating functionality and creating clear interfaces to your code. I hope the seven patterns here are a useful breakdown of different strategies available to you.</p>
<p>I haven&#39;t been exhaustive and there are certainly other options available but I have attempted to describe the most common and useful. Have I missed anything that should be included here?</p>
<p><em>Thanks to the incredibly prolific Node developer community for all the open source work from which I have done most of my learning. I encourage you to read the code of the libraries you are using and to find the great developers out there with clear, consistent and readable styles that can inspire your own. Special shout out to <a href="https://github.com/visionmedia">TJ Holowaychuk</a> whose work on Express.js, Connect and Should.js are referenced above.</em></p>
</div><footer><p class="meta"><a class="basic-alignment left" href="../../posts/first-cultivate-meetup/">&laquo; Cultivate Inaugural Meetup</a></p><div id="disqus_thread"></div><script>window.disqus_shortname = 'goodeggsbytes'; window.disqus_url = 'http://bites.goodeggs.com/posts/export-this/'</script><script async="async" src="//goodeggsbytes.disqus.com/embed.js"></script></footer></article></div></div></div><footer><div class="mission">Our mission is to grow and sustain local food systems worldwide.</div><p>©2013 Good Eggs, Inc</p></footer></body></html>