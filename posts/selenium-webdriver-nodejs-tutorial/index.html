<!DOCTYPE html><html class="no-js" lang="en"><head><meta charset="utf-8" /><title>Getting started with Selenium Webdriver for node.js | Bites from Good Eggs</title><meta name="author" content="Max Edmands" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="shortcut icon" href="/favicon.ico?v=2" /><link rel="stylesheet" href="/styles/main.css" /><link rel="alternate" title="RSS" type="application/rss+xml" href="/rss" /><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-26193287-5', 'github.io');
ga('send', 'pageview');</script></head><body><header><h1><a href="/">Bites</a></h1><ul class="unstyled nav"><li><a href="/">Blog</a></li><li><a href="/open_source/">Open Source</a></li><li><a href="/news/">News</a></li></ul></header><div id="main"><div id="content"><div><article class="post" role="article"><header><img class="author" src="http://fpio.goodeggs.com/api/file/4HBn1HQRvqTW9BdESZVX/convert?w=150&amp;h=150&amp;fit=crop&amp;align=faces&amp;cache=true" alt="Max Edmands" /><h1 class="entry-title">Getting started with Selenium Webdriver for node.js</h1><p class="meta"><a class="entry-author-name" href="/authors/max_edmands/">Max Edmands</a> on <time datetime="2014-12-30T20:00:00.000Z">December 30th, 2014</time></p></header><div class="entry-content"><p>If you&#39;re writing a web application using node.js, you will want to spend some
time writing integration tests for it. At Good Eggs, we use <code>selenium-webdriver</code>
for our integration tests. It&#39;s a reliable and comprehensive library, but
finding great documentation on the internet is surprisingly difficult.
That changes today. Here&#39;s a step-by-step guide to start controlling
a browser using <code>selenium-webdriver</code> for node.</p>
<!-- more -->

<h2 id="0-wat">0. Wat</h2>
<p><code>selenium-webdriver</code> lets you write robots that control web browsers.</p>
<p>This is incredibly useful for:</p>
<ul>
<li>Integration tests</li>
<li>Webcrawlers that can understand javascript</li>
<li>Automated screenshot-grabbing</li>
<li>You name it</li>
</ul>
<p>Here&#39;s an example of the kind of raw power this affords you:</p>
<p><img src="http://i.imgur.com/NdNlihs.gif" width=615 alt="a gif of webdriver in action"></p>
<h2 id="1-install-the-modules-you-need">1. Install the modules you need</h2>
<p>You&#39;re going to need a copy of the
<a href="https://www.npmjs.com/package/selenium-webdriver"><code>selenium-webdriver</code> module</a>. In this tutorial, I&#39;ll be
using version <code>2.44.0</code>, last updated in October 2014:</p>
<pre><code>npm <span class="hljs-operator"><span class="hljs-keyword">install</span> <span class="hljs-comment">--save selenium-webdriver@2.44.0</span></span></code></pre>

<p>You&#39;re also going to want a WebDriver implementation of some sort on your
machine. The simplest to install and use is ChromeDriver, which can also be
<a href="https://www.npmjs.com/package/chromedriver">found on npm</a>:</p>
<pre><code>npm <span class="hljs-operator"><span class="hljs-keyword">install</span> <span class="hljs-comment">--save chromedriver@2.12.0</span></span></code></pre>

<p>You&#39;ll probably want a test harness of some sort. We&#39;ve had great luck with
<a href="https://www.npmjs.com/package/mocha"><code>mocha</code></a>.</p>
<pre><code>npm <span class="hljs-operator"><span class="hljs-keyword">install</span> <span class="hljs-comment">--save mocha@2.0.1</span></span></code></pre>

<p>You&#39;ll also want an assertion library. We like <code>chai</code> and <code>chai as promised</code>:</p>
<pre><code>npm install --save chai<span class="hljs-number">@1</span>.<span class="hljs-number">10.0</span> chai-<span class="hljs-keyword">as</span>-promised<span class="hljs-number">@4</span>.<span class="hljs-number">1.1</span></code></pre>

<p>Finally, I have found that tests are much easier to read and write when they are
written with a clean, sparse syntax. CoffeeScript is my go-to choice for this.
Feel free to not use CoffeeScript, everything will still work fine, it&#39;ll just
be a tiiiiny bit less fun:</p>
<pre><code>npm <span class="hljs-operator"><span class="hljs-keyword">install</span> <span class="hljs-comment">--save coffee-script</span></span></code></pre>

<h2 id="2-set-up-your-test">2. Set up your test</h2>
<p>In this example, I&#39;ll be writing an integration test for the blog you&#39;re reading
right now! Here&#39;s what it looks like; I&#39;ll explain each line in a moment:</p>
<pre><code class="coffeescript">selenium = <span class="hljs-built_in">require</span> <span class="hljs-string">'selenium-webdriver'</span>
chai = <span class="hljs-built_in">require</span> <span class="hljs-string">'chai'</span>
chai.use <span class="hljs-built_in">require</span> <span class="hljs-string">'chai-as-promised'</span>
expect = chai.expect

before<span class="hljs-function"> -&gt;</span>
  <span class="hljs-property">@timeout</span> <span class="hljs-number">10000</span>
  <span class="hljs-property">@driver</span> = <span class="hljs-keyword">new</span> selenium.Builder()
    .withCapabilities(selenium.Capabilities.chrome())
    .build()
  <span class="hljs-property">@driver</span>.getWindowHandle()

after<span class="hljs-function"> -&gt;</span>
  <span class="hljs-property">@driver</span>.quit()

describe <span class="hljs-string">'Webdriver tutorial'</span>,<span class="hljs-function"> -&gt;</span>
  beforeEach<span class="hljs-function"> -&gt;</span>
    <span class="hljs-property">@driver</span>.get <span class="hljs-string">'http://bites.goodeggs.com/posts/selenium-webdriver-nodejs-tutorial/'</span>

  it <span class="hljs-string">'has the title of the post in the window\'s title'</span>,<span class="hljs-function"> -&gt;</span>
    expect(<span class="hljs-property">@driver</span>.getTitle()).to.eventually.contain
      <span class="hljs-string">'Getting started with Selenium Webdriver for node.js'</span>

  it <span class="hljs-string">'has publication date'</span>,<span class="hljs-function"> -&gt;</span>
    text = <span class="hljs-property">@driver</span>.findElement(<span class="hljs-attribute">css</span>: <span class="hljs-string">'.post .meta time'</span>).getText()
    expect(text).to.eventually.equal <span class="hljs-string">'December 30th, 2014'</span>

  it <span class="hljs-string">'links back to the homepage'</span>,<span class="hljs-function"> -&gt;</span>
    <span class="hljs-property">@driver</span>.findElement(<span class="hljs-attribute">linkText</span>: <span class="hljs-string">'Bites'</span>).click()
    expect(<span class="hljs-property">@driver</span>.getCurrentUrl()).to.eventually.equal <span class="hljs-string">'http://bites.goodeggs.com/'</span></code></pre>

<p>Save all that to <code>integration-test.coffee</code> and run it like this:</p>
<pre><code><span class="hljs-comment">mocha</span> <span class="hljs-comment">integration</span><span class="hljs-literal">-</span><span class="hljs-comment">test</span><span class="hljs-string">.</span><span class="hljs-comment">coffee</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">compilers</span> <span class="hljs-comment">coffee:coffee</span><span class="hljs-literal">-</span><span class="hljs-comment">script/register</span></code></pre>

<p>You should see a web browser pop up, open up this blog post, quickly flash over
to the homepage, and then close down again. Awesome, right? Now let&#39;s break it
all down to understand how it works.</p>
<h2 id="3-build-your-driver-instance">3. Build your driver instance</h2>
<p>The <code>selenium-webdriver</code> module lets you create &quot;drivers&quot; that can control
individual browser instances. There are many types of drivers that talk to
every major browser, including mobile browsers and
<a href="http://phantomjs.org/">PhantomJS</a>. They can be configured to react differently to
browser actions like log messages or alert dialogs.</p>
<p>In our example, we&#39;ll create a driver that knows how to control Google Chrome.
To do this, we create an instance of
<a href="http://selenium.googlecode.com/git/docs/api/javascript/module_selenium-webdriver_builder_class_Builder.html"><code>selenium.Builder</code></a>,
pass it a good set of defaults for Chrome, and then call its <code>build()</code> method:</p>
<pre><code class="coffeescript">selenium = <span class="hljs-built_in">require</span> <span class="hljs-string">'selenium-webdriver'</span>
driver = <span class="hljs-keyword">new</span> selenium.Builder()
  .withCapabilities(selenium.Capabilities.chrome())
  .build()</code></pre>

<h2 id="4-give-the-test-some-structure">4. Give the test some structure</h2>
<p>Using the mocha test runner, we can do most of the work for this setup step
inside a <code>before</code> block, which ensures that it happens before any of the
individual tests run. In addition, we can assign our new driver to the context
of the test by referring to it as <code>@driver</code>. Now, we&#39;ll be able to use
the driver instance in every one of our tests:</p>
<pre><code class="coffeescript">before<span class="hljs-function"> -&gt;</span>
  <span class="hljs-property">@driver</span> = <span class="hljs-keyword">new</span> selenium.Builder()
    .withCapabilities(selenium.Capabilities.chrome())
    .build()</code></pre>

<p>We&#39;ll also want to clean up after ourselves when the test is done running.
Example:</p>
<pre><code class="coffeescript">after<span class="hljs-function"> -&gt;</span>
  <span class="hljs-property">@driver</span>.quit()</code></pre>

<p>This will kill all of the the other processes that started running because of
our test setup. If you don&#39;t do this, you could end up with tons of browser
processes awkwardly idling on your machine.</p>
<p><img src="https://www.evernote.com/shard/s3/sh/8f5fe500-d628-4cf3-b5a1-2c841406fc5b/fdb6e2d880d0520afefbf24693c94589/deep/0/Screen-Shot-2014-12-17-at-4.47.00-PM.png" alt="lots and lots of chrome icons"></p>
<p>Finally, we&#39;re going to want to put all of our tests inside a <code>describe</code> block,
so that they&#39;re all in one logical place:</p>
<pre><code class="coffeescript">describe <span class="hljs-string">'Webdriver tutorial'</span>,<span class="hljs-function"> -&gt;</span>
  <span class="hljs-comment"># ...</span></code></pre>

<h2 id="5-visit-the-page">5. Visit the page</h2>
<p>In our tests, we want the browser to be looking at this blog post. We can tell
the driver to visit a page with <code>get()</code>:</p>
<pre><code class="coffeescript">beforeEach<span class="hljs-function"> -&gt;</span>
  <span class="hljs-property">@driver</span>.get <span class="hljs-string">'http://bites.goodeggs.com/posts/selenium-webdriver-nodejs-tutorial/'</span></code></pre>

<p>Some notes about this.</p>
<p>First, going to a page is an asynchronous operation, and we want to be sure that
the action of visiting the page is fully encompassed by the <code>beforeEach</code> block.
Thankfully, that is in fact what&#39;s happening here.  <code>@driver.get</code> returns a
<a href="https://promisesaplus.com/">promise</a> that&#39;s only resolved when the browser is done loading the
page, and when you return a promise from within a mocha block, mocha knows to
wait until the promise is resolved before it continues on.</p>
<p>Second, when we tell the driver to visit a page for the first time, that&#39;s
when chromedriver does all the hard work of opening a new browser instance. So
the first time we get into this <code>beforeEach</code> block, it&#39;ll take a lot longer than
all the other times -- so long that depending on the machine you&#39;re running, the
test might time out before it finishes. To alleviate this, we&#39;ll change the
<code>before</code> filter at the very beginning of our test to wait for the browser to
start up.</p>
<pre><code>before<span class="hljs-function"> -&gt;</span>
  <span class="hljs-property">@timeout</span> <span class="hljs-number">10000</span>
  <span class="hljs-comment"># ...create the driver...</span>
  <span class="hljs-property">@driver</span>.getWindowHandle()</code></pre>

<p>Using <code>@driver.getWindowHandle()</code> is something of a hack. It returns the unique
&quot;handle&quot; id for the browser window that the driver is controlling -- but it can&#39;t
have a window handle until we have a window, and we can&#39;t have a window until
the browser is running -- which means now the browser will start up in the
<code>before</code> block. <code>@timeout 10000</code> tells mocha that we&#39;ll wait for up to 10 seconds
for the browser to start running.</p>
<h2 id="6-start-verifying-some-expectations">6. Start verifying some expectations</h2>
<p>To verify our expectations, we&#39;re going to need to make some assertions. Here&#39;s
one way to set up <code>chai</code> to help with that:</p>
<pre><code class="coffeescript">chai = <span class="hljs-built_in">require</span> <span class="hljs-string">'chai'</span>
expect = chai.expect</code></pre>

<p>For our first test, we&#39;ll verify that the window&#39;s <code>&lt;title&gt;</code> attribute looks right.
We can ask the driver to tell us the title of the current page with
<code>getTitle()</code>, so let&#39;s try that:</p>
<pre><code class="coffeescript">it <span class="hljs-string">'has the title of the post in the window\'s title'</span>,<span class="hljs-function"> -&gt;</span>
  <span class="hljs-property">@driver</span>.getTitle<span class="hljs-function"><span class="hljs-params">()</span>.<span class="hljs-title">then</span> <span class="hljs-params">(title)</span> -&gt;</span>
    expect(title).to.contain
      <span class="hljs-string">'Getting started with Selenium Webdriver for node.js'</span></code></pre>

<p><code>getTitle()</code> returns a promise for the window&#39;s title (remember, we&#39;re talking
to a browser that&#39;s running in a different process, here, so pretty much
<em>everytyhing</em> that we do is going to be asynchronous). After the promise has resolved
we can run our assertion.</p>
<p>Another, cleaner-looking, way to do this is with the <code>chai-as-promised</code> library
which lets you make assertions on promises:</p>
<pre><code class="coffeescript">it <span class="hljs-string">'has the title of the post in the window\'s title'</span>,<span class="hljs-function"> -&gt;</span>
  expect(<span class="hljs-property">@driver</span>.getTitle()).to.eventually.contain
    <span class="hljs-string">'Getting started with Selenium Webdriver for node.js'</span></code></pre>

<p>Isn&#39;t that nice? Here&#39;s what we have to do all the way at the top of our file to
set that up:</p>
<pre><code class="coffeescript">chai.use <span class="hljs-built_in">require</span> <span class="hljs-string">'chai-as-promised'</span></code></pre>

<h2 id="7-querying-dom-elements-on-the-page">7. Querying DOM elements on the page</h2>
<p>Next, we&#39;ll want to make sure that the page actually looks the way we want it to
look. As it turns out, this is pretty simple, and very similar to checking the
title of the window. In our test, let&#39;s check that the publication date of the
post is what we expect it to be.</p>
<p>We know the publication date of a post can be found with the css selector <code>.post
.meta time</code>, so let&#39;s use that:</p>
<pre><code><span class="hljs-keyword">it</span> <span class="hljs-string">'has publication date'</span>, -&gt;
  <span class="hljs-keyword">text</span> = @driver.findElement(css: <span class="hljs-string">'.post .meta time'</span>).getText()
  expect(<span class="hljs-keyword">text</span>).<span class="hljs-built_in">to</span>.eventually.equal <span class="hljs-string">'December 30th, 2014'</span></code></pre>

<p>There are lots of other ways you can look for DOM elements using findElement.
Here are some of the more useful ones (or just take a look at the
<a href="http://selenium.googlecode.com/git/docs/api/javascript/namespace_webdriver_By.html#webdriver.By.Hash">documentation</a>):</p>
<ol>
<li><code>@driver.findElement(linkText: &#39;Max Edmands&#39;)</code>: Finds the first link on the
page whose text is &quot;Max Edmands&quot;</li>
<li><code>@driver.findElement(xpath: &#39;//*[@id=&quot;content&quot;]/div/article/div/pre[1]&#39;)</code>:
XPath is a powerful XML syntax selector language, and <code>findElement</code> supports
it. <a href="https://developer.mozilla.org/en-US/docs/Web/XPath">Read more about XPath on MDN if you&#39;re
curious.</a></li>
<li><code>@driver.findElement(js: &#39;return document.getElementById(&quot;content&quot;)&#39;)</code>:
You can inject arbitrary javascript that can return arbitrary DOM elements.
This example is a bit contrived, but there are many scenarios where this
could be useful. For example, if the client is using a framework, like
jQuery, you can harness that framework to find your element.</li>
</ol>
<h2 id="8-interacting-with-the-page">8. Interacting with the page</h2>
<p>Finally, let&#39;s click on a link in the page and make sure it brings us to the
right place.</p>
<pre><code class="coffeescript">it <span class="hljs-string">'links back to the homepage'</span>,<span class="hljs-function"> -&gt;</span>
  <span class="hljs-property">@driver</span>.findElement(<span class="hljs-attribute">linkText</span>: <span class="hljs-string">'Bites'</span>).click()
  expect(<span class="hljs-property">@driver</span>.getCurrentUrl()).to.eventually.equal <span class="hljs-string">'http://bites.goodeggs.com/'</span></code></pre>

<p>In this example, we&#39;re using the same <code>findElement()</code> call that I described
above, except now we&#39;re clicking on the element with <code>click()</code> instead of
asking for its text.</p>
<p>Once we&#39;ve clicked, we check the browser&#39;s current URL with
<code>@driver.getCurrentUrl()</code> and compare it to our expectation that it
should be the homepage.</p>
<h2 id="extra-credit-understanding-the-webdriver-promise-manager">Extra credit: Understanding the webdriver promise manager</h2>
<p><code>selenium-webdriver</code> allows you to write your code in a declarative,
straightforward style despite the fact that in reality everything is happening
asynchronously. This makes for really readable tests!</p>
<p>On the other hand, if you&#39;re used to writing async code in Node.JS using
promises or the more idiomatic node callback style, reading and writing
webdriver tests might be a little bit jarring at first. For example, you might
have expected that last test to have been written like this:</p>
<pre><code class="coffeescript">it <span class="hljs-string">'links back to the homepage'</span>,<span class="hljs-function"> -&gt;</span>
  <span class="hljs-property">@driver</span>.findElement(<span class="hljs-attribute">linkText</span>: <span class="hljs-string">'Bites'</span>)
    .<span class="hljs-keyword">then</span> <span class="hljs-function"><span class="hljs-params">(element)</span> -&gt;</span>
      element.click()
    .<span class="hljs-keyword">then</span><span class="hljs-function"> =&gt;</span>
      <span class="hljs-property">@driver</span>.getCurrentUrl()
    .<span class="hljs-keyword">then</span> <span class="hljs-function"><span class="hljs-params">(url)</span> -&gt;</span>
      expect(url).to.equal <span class="hljs-string">'http://bites.goodeggs.com/'</span></code></pre>

<p>Much less pretty. To make writing integration tests easier, the <code>selenium-webdriver</code>
authors wrote an awesome control-flow management utility into the library, that
basically manages all the promises under the hood, so you don&#39;t need to
explicitly write all of the <code>then()</code> calls. They have
<a href="https://code.google.com/p/selenium/wiki/WebDriverJs#Control_Flows">a pretty great write-up of this library in their user guide.</a></p>
<p>In short, the Control Flow library makes it so that whenever you ask a driver
instance to do something, it waits until the previous thing you asked it to do
is complete before it follows your latest instruction. Magic!</p>
<p>If you want, you can also add other asynchronous interactions to this control
flow, so that you can, for example, check database state after you submit a
form, or send an email before you check your inbox.</p>
<p>This is how our
<a href="https://github.com/goodeggs/mongoose-webdriver"><code>mongoose-webdriver</code></a> module
works, for instance.</p>
<p>The possibilities are endless.</p>
<h2 id="helpful-links-and-more-documentation">Helpful links and more documentation</h2>
<ul>
<li><a href="https://www.npmjs.com/package/selenium-webdriver"><code>selenium-webdriver</code> on npm</a></li>
<li><a href="http://selenium.googlecode.com/git/docs/api/javascript/index.html"><code>selenium-webdriver</code> API documentation</a></li>
<li><a href="https://code.google.com/p/selenium/wiki/WebDriverJs"><code>selenium-webdriver</code> user guide</a></li>
<li><a href="https://promisesaplus.com/">More information about the Promises/A+ standard</a></li>
</ul>
<p>Webdriver is a really powerful tool. It makes it so easy to write really
comprehensive integration tests in Node.JS! You can also use it to build
sophisticated web crawlers, automate filling in forms, you name it. How do you
use <code>selenium-webdriver</code>? What parts are confusing for you? If you have any
thoughts, please chime in with a comment!</p>
</div><footer><p class="meta"><a class="basic-alignment left" href="/posts/things-last-work-vs-school/">&laquo; Things Last: Work vs School</a><a class="basic-alignment right" href="/posts/commonjs-modules-make-brittle-singletons/">CommonJS Modules Make Brittle Singletons &raquo;</a></p><div id="disqus_thread"></div><script>window.disqus_shortname = 'goodeggsbytes'; window.disqus_url = 'http://bites.goodeggs.com/post/selenium-webdriver-nodejs-tutorial'</script><script async="async" src="//goodeggsbytes.disqus.com/embed.js"></script></footer></article></div></div></div><footer><div class="mission">Our mission is to grow and sustain local food systems worldwide.</div><p>©2013 Good Eggs, Inc</p></footer></body></html>
